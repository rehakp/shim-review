[[
This patch is a superset of the "grub2-Add-hidden-menu-entries" v2 patch:
> From a06004f4c668abd7c760a2818d0a8205da7568e7 Mon Sep 17 00:00:00 2001
> From: Alexander Graf <agraf@suse.de>
> Date: Tue, 26 Apr 2016 15:29:25 +0200
> Subject: [PATCH v2] Add hidden menu entries
> 
> The menu infrastructure is quite powerful. It allows you to define menu
> entries that can contain arbitrary grub commands that can do a lot more
> than just boot kernel entries.
> 
> For some of these it makes sense to hide them inside the normal menu
> though and instead have them available through hotkeys that get advertised
> differently. My main use case is to switch to the serial console when
> gfxterm is loaded.
> 
> So this patch adds support for hidden menu entries that are accessible
> using hotkeys, but are not accessible in the grub menu.
> 
> Signed-off-by: Alexander Graf <agraf@suse.de>
> 
> ---
> 
> v1 -> v2:
> 
> - fix default entry selection
v3:
- support unfocusable menu items that cannot be selected although they are
  still displayed
v4:
- support displaying one-line help text for any menu item below the menu
  on pressing the SPACE BAR
- make the patch to not depend on the menu-visual-adjustments patch
- fix nonfunctional skipping of unfocused menu items on entering menu
v5:
- add the `menuseparator` GRUB command
v6:
- allow entry specified by the `default' environment variable to be booted
- correct comments
v7:
- finish implementation of the default entry selection logic by not excluding it
  in show_menu() and also by making an exception in run_menu() in range check
  of the default menu item number if the item is hidden
- expand support of hidden entries to fallback ones
- correct code formatting
]]
diff -urp a/grub-core/commands/legacycfg.c b/grub-core/commands/legacycfg.c
--- a/grub-core/commands/legacycfg.c	2021-05-18 14:16:49.020000000 +0200
+++ b/grub-core/commands/legacycfg.c	2021-05-18 14:16:10.830000000 +0200
@@ -143,7 +143,7 @@ legacy_file (const char *filename)
 	    args[0] = oldname;
 	    grub_normal_add_menu_entry (1, args, NULL, NULL, "legacy",
 					NULL, NULL,
-					entrysrc, 0);
+					entrysrc, NULL, 0, 0, 0);
 	    grub_free (args);
 	    entrysrc[0] = 0;
 	    grub_free (oldname);
@@ -205,7 +205,7 @@ legacy_file (const char *filename)
 	}
       args[0] = entryname;
       grub_normal_add_menu_entry (1, args, NULL, NULL, NULL,
-				  NULL, NULL, entrysrc, 0);
+				  NULL, NULL, entrysrc, NULL, 0, 0, 0);
       grub_free (args);
     }
 
diff -urp a/grub-core/commands/menuentry.c b/grub-core/commands/menuentry.c
--- a/grub-core/commands/menuentry.c	2021-05-18 14:16:49.020000000 +0200
+++ b/grub-core/commands/menuentry.c	2021-05-18 14:16:10.830000000 +0200
@@ -43,6 +43,12 @@ static const struct grub_arg_option opti
        anyone can boot it.  */
     {"unrestricted", 0, 0, N_("This entry can be booted by any user."),
      0, ARG_TYPE_NONE},
+    {"helptext", 0, 0, N_("Help text for this entry shown below the menu."),
+     N_("STRING"), ARG_TYPE_STRING},
+    {"hidden", 0, 0, N_("This entry is invisible in menus."),
+     0, ARG_TYPE_NONE},
+    {"unfocusable", 0, 0, N_("This entry cannot be selected."),
+     0, ARG_TYPE_NONE},
     {0, 0, 0, 0, 0, 0}
   };
 
@@ -79,7 +85,8 @@ grub_normal_add_menu_entry (int argc, co
 			    char **classes, const char *id,
 			    const char *users, const char *hotkey,
 			    const char *prefix, const char *sourcecode,
-			    int submenu)
+			    const char *helptext, int submenu,
+			    int hidden, int unfocusable)
 {
   int menu_hotkey = 0;
   char **menu_args = NULL;
@@ -87,6 +94,7 @@ grub_normal_add_menu_entry (int argc, co
   char *menu_title = NULL;
   char *menu_sourcecode = NULL;
   char *menu_id = NULL;
+  char *menu_helptext = NULL;
   struct grub_menu_entry_class *menu_classes = NULL;
 
   grub_menu_t menu;
@@ -140,6 +148,13 @@ grub_normal_add_menu_entry (int argc, co
 	menu_hotkey = hotkey[0];
     }
 
+  if (helptext)
+    {
+      menu_helptext = grub_strdup (helptext);
+      if (! menu_helptext)
+	goto fail;
+    }
+
   if (! argc)
     {
       grub_error (GRUB_ERR_MENU, "menuentry is missing title");
@@ -188,13 +203,20 @@ grub_normal_add_menu_entry (int argc, co
   (*last)->argc = argc;
   (*last)->args = menu_args;
   (*last)->sourcecode = menu_sourcecode;
+  (*last)->helptext = menu_helptext;
   (*last)->submenu = submenu;
+  (*last)->hidden = hidden;
+  (*last)->unfocusable = unfocusable;
+  (*last)->separator = 0;
+
+  if (!hidden)
+    menu->size++;
 
-  menu->size++;
   return GRUB_ERR_NONE;
 
  fail:
 
+  grub_free (menu_helptext);
   grub_free (menu_sourcecode);
   {
     int i;
@@ -287,7 +309,9 @@ grub_cmd_menuentry (grub_extcmd_context_
 				       users,
 				       ctxt->state[2].arg, 0,
 				       ctxt->state[3].arg,
-				       ctxt->extcmd->cmd->name[0] == 's');
+				       ctxt->state[6].arg,
+				       ctxt->extcmd->cmd->name[0] == 's',
+				       ctxt->state[7].set, ctxt->state[8].set);
 
   src = args[argc - 1];
   args[argc - 1] = NULL;
@@ -304,7 +328,9 @@ grub_cmd_menuentry (grub_extcmd_context_
 				  ctxt->state[0].args, ctxt->state[4].arg,
 				  users,
 				  ctxt->state[2].arg, prefix, src + 1,
-				  ctxt->extcmd->cmd->name[0] == 's');
+				  ctxt->state[6].arg,
+				  ctxt->extcmd->cmd->name[0] == 's',
+				  ctxt->state[7].set, ctxt->state[8].set);
 
   src[len - 1] = ch;
   args[argc - 1] = src;
@@ -312,6 +338,49 @@ grub_cmd_menuentry (grub_extcmd_context_
   return r;
 }
 
+static grub_err_t
+grub_cmd_menuseparator (struct grub_command *cmd __attribute__ ((unused)),
+	       int argc __attribute__ ((unused)),
+	       char *argv[] __attribute__ ((unused)))
+{
+  grub_menu_t menu;
+  grub_menu_entry_t *last;
+
+  menu = grub_env_get_menu ();
+  if (! menu)
+    return grub_error (GRUB_ERR_MENU, "no menu context");
+
+  last = &menu->entry_list;
+
+  /* Add the menu entry at the end of the list.  */
+  while (*last)
+    last = &(*last)->next;
+
+  *last = grub_zalloc (sizeof (**last));
+  if (! *last)
+    return grub_errno;
+
+  (*last)->title = NULL;
+  (*last)->id = NULL;
+  (*last)->hotkey = 0;
+  (*last)->classes = NULL;
+  (*last)->restricted = 0;
+  (*last)->users = NULL;
+  (*last)->argc = 0;
+  (*last)->args = NULL;
+  (*last)->sourcecode = NULL;
+  (*last)->helptext = NULL;
+  (*last)->submenu = 0;
+  (*last)->hidden = 0;
+  (*last)->unfocusable = 0;
+  (*last)->separator = 1;
+
+  menu->size++;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_command_t cmd_menuseparator;
 static grub_extcmd_t cmd, cmd_sub;
 
 void
@@ -328,6 +397,9 @@ grub_menu_init (void)
 				  | GRUB_COMMAND_FLAG_EXTRACTOR,
 				  N_("BLOCK"), N_("Define a submenu."),
 				  options);
+  cmd_menuseparator =
+    grub_register_command ("menuseparator", grub_cmd_menuseparator,
+			   0, N_("Add the menu separator menu item."));
 }
 
 void
@@ -335,4 +407,5 @@ grub_menu_fini (void)
 {
   grub_unregister_extcmd (cmd);
   grub_unregister_extcmd (cmd_sub);
+  grub_unregister_command (cmd_menuseparator);
 }
diff -urp a/grub-core/normal/menu.c b/grub-core/normal/menu.c
--- a/grub-core/normal/menu.c	2021-05-18 14:16:49.020000000 +0200
+++ b/grub-core/normal/menu.c	2021-05-18 14:16:10.900000000 +0200
@@ -34,6 +34,7 @@
 #include <grub/dl.h>
 
 #include <grub/speaker.h>
+#include <grub/charset.h>
 
 /* Time to delay after displaying an error message about a default/fallback
    entry failing to boot.  */
@@ -42,6 +43,9 @@
 grub_err_t (*grub_gfxmenu_try_hook) (int entry, grub_menu_t menu,
 				     int nested) = NULL;
 
+#define MENU_INCLUDE_HIDDEN 0x10000
+#define MENU_INCLUDE_SEPARATOR 0x20000
+
 enum timeout_style {
   TIMEOUT_STYLE_MENU,
   TIMEOUT_STYLE_COUNTDOWN,
@@ -81,9 +85,31 @@ grub_menu_entry_t
 grub_menu_get_entry (grub_menu_t menu, int no)
 {
   grub_menu_entry_t e;
+  unsigned sep_show = 0;
 
-  for (e = menu->entry_list; e && no > 0; e = e->next, no--)
-    ;
+  if (no & MENU_INCLUDE_SEPARATOR)
+    {
+      no &= ~MENU_INCLUDE_SEPARATOR;
+      sep_show = 1;
+    }
+  if (no & MENU_INCLUDE_HIDDEN)
+    {
+      no &= ~MENU_INCLUDE_HIDDEN;
+
+      for (e = menu->entry_list; e && no > 0; e = e->next, no--)
+        ;
+    }
+  else
+    {
+      for (e = menu->entry_list; e && no > 0; e = e->next, no--)
+	{
+	  /* Skip hidden entries */
+	  while (e && (e->hidden || (e->separator && !sep_show)))
+	    e = e->next;
+	}
+      while (e && (e->hidden || (e->separator && !sep_show)))
+	e = e->next;
+    }
 
   return e;
 }
@@ -95,10 +121,10 @@ get_entry_index_by_hotkey (grub_menu_t m
   grub_menu_entry_t entry;
   int i;
 
-  for (i = 0, entry = menu->entry_list; i < menu->size;
+  for (i = 0, entry = menu->entry_list; entry;
        i++, entry = entry->next)
     if (entry->hotkey == hotkey)
-      return i;
+      return i | MENU_INCLUDE_HIDDEN;
 
   return -1;
 }
@@ -354,7 +380,7 @@ grub_menu_execute_with_fallback (grub_me
       grub_print_error ();
       grub_errno = GRUB_ERR_NONE;
 
-      entry = grub_menu_get_entry (menu, fallback_entry);
+      entry = grub_menu_get_entry (menu, fallback_entry | MENU_INCLUDE_HIDDEN);
       callback->notify_fallback (entry, callback_data);
       grub_menu_execute_entry (entry, 1);
       /* If the function call to execute the entry returns at all, then this is
@@ -453,6 +479,24 @@ menu_print_timeout (int timeout)
     cur->print_timeout (timeout, cur->data);
 }
 
+static int help_displayed = 0;
+
+static void
+menu_print_help_text (int entry, grub_menu_t menu)
+{
+  struct grub_menu_viewer *cur;
+  grub_menu_entry_t e;
+
+  /* retrieve the current menu entry */
+  for (e = menu->entry_list; e && entry > 0; e = e->next, entry--) ;
+  if (!e->helptext) return;
+
+  for (cur = viewers; cur; cur = cur->next)
+    cur->print_help_text (e->helptext, cur->data);
+
+  help_displayed = 1;
+}
+
 static void
 menu_fini (void)
 {
@@ -466,6 +510,81 @@ menu_fini (void)
   viewers = NULL;
 }
 
+/* skip unfocusable menu entries if necessary and set a new menu entry index */
+static void
+skip_unfocusable (int *entry, grub_menu_t menu, int direction)
+{
+  grub_menu_entry_t e;
+  int no, lastno = -1;
+
+  /* fix possibly incorrect direction */
+  if (grub_abs (direction) != 1)
+    direction = 1;
+
+  for (no = 0, e = menu->entry_list; e; e = e->next, no++) 
+    {
+      if (e->hidden || e->unfocusable || e->separator)
+        continue;
+      if (no > *entry && lastno >= 0 && direction == -1)
+        break;
+      lastno = no;
+      if (no == *entry)
+        break;
+      if (no > *entry && lastno >= 0 && direction == 1)
+        break;
+    }
+
+  if (lastno >= 0)
+    *entry = lastno;
+}
+
+/* fill in missing menu separator item titles */
+static void
+create_menu_separators (grub_menu_t menu)
+{
+  grub_menu_entry_t etmp, *e;
+  int longest_title_len = 0;
+
+  /* determine the longest menu item title */
+  for (etmp = menu->entry_list; etmp; etmp = etmp->next) 
+    {
+      if (etmp->hidden)
+        continue;
+      int len = grub_strlen (etmp->title);
+      if (len > longest_title_len)
+        longest_title_len = len;
+    }
+
+  /* box drawing Unicode characters will be 3 bytes in UTF-8 for each */
+  char *separator = grub_malloc (longest_title_len * 3 + 1);
+  if (!separator)
+    {
+      grub_errno = GRUB_ERR_OUT_OF_MEMORY;
+      return;
+    }
+
+  grub_ssize_t nchars;
+  grub_uint8_t *p = (grub_uint8_t *)separator;
+  grub_uint8_t * const last_pos = (grub_uint8_t *)separator + longest_title_len * 3;
+  for (; longest_title_len > 0; p += nchars, longest_title_len--)
+    {
+      nchars = grub_encode_utf8_character (p, last_pos, GRUB_UNICODE_LIGHT_HLINE);
+      if (nchars < 0)
+	{
+	  grub_free (separator);
+	  return;
+	}
+    }
+  *p = 0;
+
+  /* fill in NULL menu titles (menu separators) */
+  for (e = &menu->entry_list; *e; e = &(*e)->next) 
+    if (! (*e)->title)
+      (*e)->title = grub_strdup (separator);
+
+  grub_free (separator);
+}
+
 static void
 menu_init (int entry, grub_menu_t menu, int nested, grub_uint64_t *frame_speed, int *egn_refresh)
 {
@@ -534,6 +653,16 @@ clear_timeout (void)
     cur->clear_timeout (cur->data);
 }
 
+static void
+clear_help_text (void)
+{
+  struct grub_menu_viewer *cur;
+  for (cur = viewers; cur; cur = cur->next)
+    cur->clear_help_text (cur->data);
+
+  help_displayed = 0;
+}
+
 void
 grub_menu_register_viewer (struct grub_menu_viewer *viewer)
 {
@@ -571,6 +700,7 @@ get_entry_number (grub_menu_t menu, cons
 {
   const char *val;
   int entry;
+  grub_menu_entry_t e;
 
   val = grub_env_get (name);
   if (! val)
@@ -583,9 +713,13 @@ get_entry_number (grub_menu_t menu, cons
   if (grub_errno == GRUB_ERR_BAD_NUMBER)
     {
       /* See if the variable matches the title of a menu entry.  */
-      grub_menu_entry_t e = menu->entry_list;
+      e = menu->entry_list;
       int i;
 
+      /* skip separator entries (hidden entries can still be booted) */
+      while (e && e->separator)
+	e = e->next;
+
       grub_errno = GRUB_ERR_NONE;
 
       for (i = 0; e; i++)
@@ -594,14 +728,29 @@ get_entry_number (grub_menu_t menu, cons
 	      || menuentry_eq (e->id, val))
 	    {
 	      entry = i;
+	      /* mark hidden entry to allow its booting */
+	      if (e->hidden)
+	        entry |= MENU_INCLUDE_HIDDEN;
 	      break;
 	    }
 	  e = e->next;
+
+          /* skip separator entries (hidden entries can still be booted) */
+	  while (e && e->separator)
+	    e = e->next;
 	}
 
       if (! e)
 	entry = -1;
     }
+  else
+    {
+      /* determine if a number in a variable corresponds to a hidden entry */
+      e = grub_menu_get_entry (menu, entry | MENU_INCLUDE_HIDDEN);
+      /* mark hidden entry to allow its booting */
+      if (e->hidden)
+	entry |= MENU_INCLUDE_HIDDEN;
+    }
 
   if (grub_errno != GRUB_ERR_NONE)
     {
@@ -653,6 +802,7 @@ static int
 run_menu (grub_menu_t menu, int nested, int *auto_boot)
 {
   grub_uint64_t saved_time;
+  int default_hidden = 0;
   int default_entry, current_entry;
   int timeout;
   enum timeout_style timeout_style;
@@ -668,10 +818,15 @@ run_menu (grub_menu_t menu, int nested,
   grub_uint64_t frame_speed = engine_get_speed (ENGINE_FRAME_SPEED);
 
   default_entry = get_entry_number (menu, "default");
+  if (default_entry & MENU_INCLUDE_HIDDEN)
+    {
+      default_entry &= ~MENU_INCLUDE_HIDDEN;
+      default_hidden = 1;
+    }
 
   /* If DEFAULT_ENTRY is not within the menu entries, fall back to
-     the first entry.  */
-  if (default_entry < 0 || default_entry >= menu->size)
+     the first entry. However, allow hidden menu entries which do not count.  */
+  if (default_entry < 0 || (default_entry >= menu->size && !default_hidden))
     default_entry = 0;
 
   menu_tones_count = 0;
@@ -770,6 +925,8 @@ run_menu (grub_menu_t menu, int nested,
     }
 
   current_entry = default_entry;
+  skip_unfocusable (&current_entry, menu, 1);
+  create_menu_separators (menu);
 
  refresh:
   menu_init (current_entry, menu, nested, &frame_speed, &egn_refresh);
@@ -837,17 +994,22 @@ run_menu (grub_menu_t menu, int nested,
 	      clear_timeout ();
 	    }
 
+	  if (help_displayed)
+	    clear_help_text ();
+
 	  switch (c)
 	    {
 	    case GRUB_TERM_KEY_HOME:
 	    case GRUB_TERM_CTRL | 'a':
 	      current_entry = 0;
+	      skip_unfocusable (&current_entry, menu, -1);
 	      menu_set_chosen_entry (current_entry);
 	      break;
 
 	    case GRUB_TERM_KEY_END:
 	    case GRUB_TERM_CTRL | 'e':
 	      current_entry = menu->size - 1;
+	      skip_unfocusable (&current_entry, menu, 1);
 	      menu_set_chosen_entry (current_entry);
 	      break;
 
@@ -856,6 +1018,7 @@ run_menu (grub_menu_t menu, int nested,
 	    case '^':
 	      if (current_entry > 0)
 		current_entry--;
+	      skip_unfocusable (&current_entry, menu, -1);
 	      menu_set_chosen_entry (current_entry);
 	      break;
 
@@ -864,6 +1027,7 @@ run_menu (grub_menu_t menu, int nested,
 	    case 'v':
 	      if (current_entry < menu->size - 1)
 		current_entry++;
+	      skip_unfocusable (&current_entry, menu, 1);
 	      menu_set_chosen_entry (current_entry);
 	      break;
 
@@ -873,6 +1037,7 @@ run_menu (grub_menu_t menu, int nested,
 		current_entry = 0;
 	      else
 		current_entry -= GRUB_MENU_PAGE_SIZE;
+	      skip_unfocusable (&current_entry, menu, -1);
 	      menu_set_chosen_entry (current_entry);
 	      break;
 
@@ -882,10 +1047,12 @@ run_menu (grub_menu_t menu, int nested,
 		current_entry += GRUB_MENU_PAGE_SIZE;
 	      else
 		current_entry = menu->size - 1;
+	      skip_unfocusable (&current_entry, menu, 1);
 	      menu_set_chosen_entry (current_entry);
 	      break;
 
 	    case ' ':
+	      menu_print_help_text (current_entry, menu);
 	      beep_menu_item (current_entry);
 	      break;
 
@@ -999,7 +1166,8 @@ show_menu (grub_menu_t menu, int nested,
       if (boot_entry < 0)
 	break;
 
-      e = grub_menu_get_entry (menu, boot_entry);
+      e = grub_menu_get_entry (menu, boot_entry
+			       | (auto_boot ? MENU_INCLUDE_HIDDEN : 0));
       if (! e)
 	continue; /* Menu is empty.  */
 
diff -urp a/grub-core/normal/menu_text.c b/grub-core/normal/menu_text.c
--- a/grub-core/normal/menu_text.c	2021-05-18 14:16:49.020000000 +0200
+++ b/grub-core/normal/menu_text.c	2021-05-18 14:16:10.900000000 +0200
@@ -45,6 +45,8 @@ struct menu_viewer_data
   struct grub_term_output *term;
 };
 
+#define MENU_INCLUDE_SEPARATOR 0x20000
+
 static inline int
 grub_term_cursor_x (const struct grub_term_screen_geometry *geo)
 {
@@ -282,10 +284,14 @@ print_entries (grub_menu_t menu, const s
       else
 	grub_putcode (' ', data->term);
     }
-  e = grub_menu_get_entry (menu, data->first);
+  e = grub_menu_get_entry (menu, data->first | MENU_INCLUDE_SEPARATOR);
 
   for (i = 0; i < data->geo.num_entries; i++)
     {
+      /* Skip hidden entries */
+      while (e && e->hidden)
+	e = e->next;
+
       print_entry (data->geo.first_entry_y + i, data->offset == i,
 		   e, data);
       if (e)
@@ -479,6 +485,47 @@ menu_text_print_timeout (int timeout, vo
 }
 
 static void
+menu_text_print_help_text (const char *helptext, void *dataptr)
+{
+  struct menu_viewer_data *data = dataptr;
+  struct grub_term_coordinate *pos;
+  grub_uint32_t *unicode_help, *last_position;
+  grub_ssize_t len;
+  int i;
+  grub_uint8_t old_color_highlight;
+
+  len = grub_utf8_to_ucs4_alloc (helptext, &unicode_help, &last_position);
+  if (!unicode_help)
+    {
+      grub_free (unicode_help);
+      return;
+    }
+
+  for (i = 0; i < len; i++)
+    if (unicode_help[i] == '\n' || unicode_help[i] == '\b'
+	|| unicode_help[i] == '\r' || unicode_help[i] == '\e')
+      unicode_help[i] = ' ';
+
+  old_color_highlight = grub_term_highlight_color;
+  /* draw help text white on black */
+  grub_term_highlight_color = 0x0F;
+  grub_term_setcolorstate (data->term, GRUB_TERM_COLOR_HIGHLIGHT);
+  pos = grub_term_save_pos ();
+  grub_term_gotoxy (data->term,
+		    (struct grub_term_coordinate) {
+			(grub_term_width (data->term) - len - STANDARD_MARGIN * 2) / 2 + STANDARD_MARGIN,
+			data->geo.timeout_y });
+  /* print the help text restricted to one line,
+     trimmed by a horizontal ellipsis should it overflow */
+  grub_print_ucs4_menu (unicode_help, last_position, 0, STANDARD_MARGIN, data->term, 0, 1, 0x2026, 0);
+  grub_term_restore_pos (pos);
+  grub_term_setcolorstate (data->term, GRUB_TERM_COLOR_NORMAL);
+  grub_term_highlight_color = old_color_highlight;
+  grub_term_refresh (data->term);
+  grub_free (unicode_help);
+}
+
+static void
 menu_text_set_chosen_entry (int entry, void *dataptr)
 {
   struct menu_viewer_data *data = dataptr;
@@ -503,11 +550,11 @@ menu_text_set_chosen_entry (int entry, v
   else
     {
       print_entry (data->geo.first_entry_y + oldoffset, 0,
-		   grub_menu_get_entry (data->menu, data->first + oldoffset),
-		   data);
+		   grub_menu_get_entry (data->menu, (data->first + oldoffset)
+					| MENU_INCLUDE_SEPARATOR), data);
       print_entry (data->geo.first_entry_y + data->offset, 1,
-		   grub_menu_get_entry (data->menu, data->first + data->offset),
-		   data);
+		   grub_menu_get_entry (data->menu, (data->first + data->offset)
+					| MENU_INCLUDE_SEPARATOR), data);
     }
   grub_term_refresh (data->term);
 }
@@ -554,6 +601,22 @@ menu_text_clear_timeout (void *dataptr)
   grub_term_refresh (data->term);
 }
 
+static void
+menu_text_clear_help_text (void *dataptr)
+{
+  struct menu_viewer_data *data = dataptr;
+  struct grub_term_coordinate *pos;
+
+  pos = grub_term_save_pos ();
+  grub_term_gotoxy (data->term,
+		    (struct grub_term_coordinate) {
+			STANDARD_MARGIN,
+			data->geo.timeout_y });
+  grub_print_spaces (data->term, grub_term_width (data->term) - STANDARD_MARGIN * 2);
+  grub_term_restore_pos (pos);
+  grub_term_refresh (data->term);
+}
+
 grub_err_t 
 grub_menu_try_text (struct grub_term_output *term, 
 		    int entry, grub_menu_t menu, int nested)
@@ -576,7 +639,9 @@ grub_menu_try_text (struct grub_term_out
   instance->data = data;
   instance->set_chosen_entry = menu_text_set_chosen_entry;
   instance->print_timeout = menu_text_print_timeout;
+  instance->print_help_text = menu_text_print_help_text;
   instance->clear_timeout = menu_text_clear_timeout;
+  instance->clear_help_text = menu_text_clear_help_text;
   instance->fini = menu_text_fini;
 
   data->menu = menu;
diff -urp a/include/grub/menu.h b/include/grub/menu.h
--- a/include/grub/menu.h	2021-05-18 14:16:49.020000000 +0200
+++ b/include/grub/menu.h	2021-05-18 14:16:10.940000000 +0200
@@ -53,6 +53,9 @@ struct grub_menu_entry
   /* The sourcecode of the menu entry, used by the editor.  */
   const char *sourcecode;
 
+  /* The help text displayed below the menu if the Space Bar is pressed.  */
+  const char *helptext;
+
   /* Parameters to be passed to menu definition.  */
   int argc;
   char **args;
@@ -61,6 +64,12 @@ struct grub_menu_entry
 
   int submenu;
 
+  int hidden;
+
+  int unfocusable;
+
+  int separator;
+
   /* The next element.  */
   struct grub_menu_entry *next;
 };
diff -urp a/include/grub/menu_viewer.h b/include/grub/menu_viewer.h
--- a/include/grub/menu_viewer.h	2021-05-18 14:16:49.020000000 +0200
+++ b/include/grub/menu_viewer.h	2021-05-18 14:16:10.940000000 +0200
@@ -33,6 +33,8 @@ struct grub_menu_viewer
   void (*set_chosen_entry) (int entry, void *data);
   void (*print_timeout) (int timeout, void *data);
   void (*clear_timeout) (void *data);
+  void (*print_help_text) (const char *helptext, void *data);
+  void (*clear_help_text) (void *data);
   void (*set_animation_state) (int need_refresh, void *data);
   void (*fini) (void *fini);
 };
diff -urp a/include/grub/normal.h b/include/grub/normal.h
--- a/include/grub/normal.h	2021-05-18 14:16:49.020000000 +0200
+++ b/include/grub/normal.h	2021-05-18 14:16:10.940000000 +0200
@@ -145,7 +145,8 @@ grub_normal_add_menu_entry (int argc, co
 			    const char *id,
 			    const char *users, const char *hotkey,
 			    const char *prefix, const char *sourcecode,
-			    int submenu);
+			    const char *helptext, int submenu,
+			    int hidden, int unfocusable);
 
 grub_err_t
 grub_normal_set_password (const char *user, const char *password);
